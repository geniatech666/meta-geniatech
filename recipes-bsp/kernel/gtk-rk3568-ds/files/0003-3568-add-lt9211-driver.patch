From 6fa05898b667fd407beda298a85033293ed816d4 Mon Sep 17 00:00:00 2001
From: "fu.qiang" <fu.qiang@geniatech.com>
Date: Sun, 29 Sep 2024 11:56:09 +0800
Subject: [PATCH] 3568 lt9211 driver debug

---
 drivers/gpu/drm/panel/Kconfig        |    2 +-
 drivers/gpu/drm/panel/panel-simple.c |    7 +-
 drivers/input/touchscreen/Kconfig    |    2 +-
 drivers/video/Kconfig                |    1 +
 drivers/video/Makefile               |    1 +
 drivers/video/lt9211/Kconfig         |    8 +
 drivers/video/lt9211/Makefile        |    1 +
 drivers/video/lt9211/lt9211_1080p.c  | 1394 ++++++++++++++++++++++++++
 drivers/video/lt9211/lt9211_1080p.h  |   96 ++
 9 files changed, 1509 insertions(+), 3 deletions(-)
 create mode 100644 drivers/video/lt9211/Kconfig
 create mode 100644 drivers/video/lt9211/Makefile
 create mode 100644 drivers/video/lt9211/lt9211_1080p.c
 create mode 100644 drivers/video/lt9211/lt9211_1080p.h

diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 3b844f217..addfc3462 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -71,7 +71,7 @@ config DRM_PANEL_SIMPLE
 
 config TINKER_MCU
         tristate "tinker mcu"
-        default y
+        default n
         depends on I2C
         help
           Control the power of ASUS panel on tinker board.
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 58dbf1264..757c9a3d5 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -43,6 +43,9 @@
 
 #include "panel-simple.h"
 
+#ifdef CONFIG_LVDS_LT9211_1080P 
+extern void lt9211_mipitolvds_init(void);
+#endif
 enum panel_simple_cmd_type {
 	CMD_TYPE_DEFAULT,
 	CMD_TYPE_SPI
@@ -706,7 +709,9 @@ static int panel_simple_enable(struct drm_panel *panel)
 	tinker_mcu_screen_power_up();
 	tc358762_dsi_init(p);
 	#endif
-
+	#ifdef CONFIG_LVDS_LT9211_1080P 
+	lt9211_mipitolvds_init();
+	#endif
 	if (p->desc->delay.enable)
 		panel_simple_msleep(p->desc->delay.enable);
 
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 0f3b2f757..a2e1adbb3 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1376,7 +1376,7 @@ config TOUCHSCREEN_ZINITIX
 
 config TOUCHSCREEN_TINKER_FT5406
        tristate "tinker ft5406"
-       default y
+       default n
        depends on I2C
        help
          Control ft5406 touch ic.
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index e4c52ca82..48957fb18 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -19,6 +19,7 @@ source "drivers/gpu/ipu-v3/Kconfig"
 
 source "drivers/gpu/drm/Kconfig"
 source "drivers/gpu/arm/Kconfig"
+source "drivers/video/lt9211/Kconfig"
 
 menu "Frame buffer Devices"
 source "drivers/video/fbdev/Kconfig"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index b355e2fcb..0deeac9ea 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -9,6 +9,7 @@ obj-y				  += backlight/
 obj-y				  += rockchip/
 
 obj-y				  += fbdev/
+obj-y                             += lt9211/
 
 obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
 ifeq ($(CONFIG_OF),y)
diff --git a/drivers/video/lt9211/Kconfig b/drivers/video/lt9211/Kconfig
new file mode 100644
index 000000000..7a4720f23
--- /dev/null
+++ b/drivers/video/lt9211/Kconfig
@@ -0,0 +1,8 @@
+menu "Lt9211 Config"
+
+config LVDS_LT9211_1080P
+    tristate "Lt9211 2 port"
+    help
+     Say Y here if you want to enable port of lt9211.
+
+endmenu
diff --git a/drivers/video/lt9211/Makefile b/drivers/video/lt9211/Makefile
new file mode 100644
index 000000000..8d02aa256
--- /dev/null
+++ b/drivers/video/lt9211/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_LVDS_LT9211_1080P)    += lt9211_1080p.o
diff --git a/drivers/video/lt9211/lt9211_1080p.c b/drivers/video/lt9211/lt9211_1080p.c
new file mode 100644
index 000000000..c2ff5fe72
--- /dev/null
+++ b/drivers/video/lt9211/lt9211_1080p.c
@@ -0,0 +1,1394 @@
+/******************************************************************************
+  * @project: LT9211
+  * @file: lt9211.c
+  * @author: caizd
+  * @company: LONTIUM COPYRIGHT and CONFIDENTIAL
+  * @date: 2019.09.05
+******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/async.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/input/mt.h>
+#include <asm/uaccess.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include "lt9211_1080p.h"
+
+#define LT9211_I2C_NAME "lt9211"
+
+#define LT9211_CONFIG_CHIP
+#define LT9211_VEDIO_CHECK_DEBUG
+//#define LT9211_BT_SET
+
+//#define LT9211_PATTERN_TEST  1
+
+/* Write Register Readback Direct Write Register Value Write Right or Not */
+//#define LT9211_DEBUG_REG_VALUE
+
+/* Print register values to log */
+//#define LT9211_DEBUG_REGS
+
+/* Print system init clk reg value */
+//#define LT9211_SYSTEMINIT_DEBUG_REG
+
+/* Print mipi status reg value */
+//#define LT9211_MIPI_STATUS
+
+#define LVDS_1PORT  1
+#define LVDS_2PORT  2
+
+#define VESA    1
+#define JEIDA   2
+
+#define DEPTH_6BIT  6
+#define DEPTH_8BIT  8
+
+#define SYNC_MODE   1
+#define DE_MODE     2
+
+int mipi_dsi_2lvds_init = 0; //add lt9211 connection detection processing
+
+struct lt9211_priv {
+
+	struct	lt9211_device *lt9211;
+	unsigned int initb;
+	unsigned int i2c_bus_index;
+	unsigned long base_addr;
+	unsigned int input_port;    //0: porA  1: portB  2: porA and portB  //add by xsj
+	unsigned int output_port;	//0: por0  1: port1  2: por1 and port2  //add by xsj
+	unsigned int output_swap;  //add by xsj
+
+	int lvds_data_formate; /* 1:VESA; 2:JEIDA; */
+	int lvds_color_depth;  /* 6:rgb666; 8:rgb888; */
+	int lvds_mode; /* 1:SYNC; 2:DE; */
+	int reg_config;
+
+	int reset_gpio;
+	//int shlr_gpio; /* Horizontal scan direction control*/
+	//int updn_gpio;	/*Vertical scan direction control*/
+	int screen_reset;	//Standby signal
+	int screen_stbyb;	//Reset signal
+	struct i2c_adapter *pI2cAdapter;
+	struct i2c_client	*pI2cClient;
+	struct device *dev;
+};
+
+struct lt9211_priv *lt9211_info = NULL;
+struct video_timing *pvideo_format;
+
+/*
+ * The screen datesheet that needs to be debugged sets the timing timing parameters and the front and back order parameters.
+ * (The parameters here should be consistent with the parameters configuration of the SOC platform mipi).
+ * Row total pixel Hdisplay + HFP + HSYNC + HBP.
+ * Column total pixel Vdisplay + VFP + VSYNC + VBP.
+ * The value of pclk_khz is the same as that of clock-frequency, for example, here pclk_khz = 148500000, and the output frame Rate is about 60 hz.
+ * The value of pclk_khz is the same as that of clock-frequency, for example, here pclk_khz = 74250000, and the output frame Rate is about 30 hz.
+ */
+
+//------------------------------------------{ hfp, hs, hbp,hact,htotal,vfp, vs, vbp, vact,vtotal,pclk_khz};
+struct video_timing video_640x480_60Hz     ={ 8, 96,  40, 640,   800, 33,  2,  10, 480,   525,  25000};
+struct video_timing video_720x480_60Hz     ={16, 62,  60, 720,   858,  9,  6,  30, 480,   525,  27000};
+struct video_timing video_800x480_60Hz     ={40, 20,  60, 800,   920, 10,  5,  10, 480,   505,  27876};
+struct video_timing video_1024x600_60Hz    ={80, 80, 160,1024,  1344,  12,  5,  7, 600,    624,  51000};
+struct video_timing video_1280x720_60Hz    ={110,40, 220,1280,  1650,  5,  5,  20, 720,   750,  74250};
+//struct video_timing video_1280x800_60Hz    ={15, 10, 25, 1280,  1330,  4,  2,  6, 800,   812,  65000};
+/*dlu 10.1*/struct video_timing video_1280x800_60Hz    ={40, 60, 220, 1280,  1600,  7,  10,  21, 800,   838,  65930};
+struct video_timing video_1920x720_60Hz   = {88, 44, 148,1920,  2200,  3,  1,  4, 720, 728, 83000};
+
+struct video_timing video_1280x720_30Hz    ={110,40, 220,1280,  1650,  5,  5,  20, 720,   750,  74250};
+struct video_timing video_1280x1024_60hz   ={60, 90, 258,1280,  1688,  8,  11, 23, 1024,  1066, 108000};
+struct video_timing video_1366x768_60Hz    ={26, 110,110,1366,  1592,  13, 6,  13, 768,   800,  81000};
+struct video_timing video_1920x1080_30Hz   ={88, 44, 148,1920,  2200,  4,  5,  36, 1080, 1125,  74250};
+struct video_timing video_1920x1080_60Hz   ={88, 44, 148,1920,  2200,  4,  5,  36, 1080, 1125, 148500};
+struct video_timing video_3840x1080_60Hz   ={176,88, 296,3840,  4400,  4,  5,  36, 1080, 1125, 297000};
+struct video_timing video_1920x1200_60Hz   ={32, 8,  96,1920,  	2056,  4,  2,  4, 1200,  1210, 149500};
+struct video_timing video_3840x2160_30Hz   ={176,88, 296,3840,  4400,  8,  10, 72, 2160, 2250, 297000};
+struct video_timing video_3840x2160_60Hz   ={176,88, 296,3840,  4400,  8,  10, 72, 2160, 2250, 594000};
+
+static int lt9211_i2c_read(unsigned char *buff, u8 reg, unsigned len)
+{
+	int res = 0;
+	struct i2c_msg msgs[2];
+
+	if (lt9211_info->pI2cClient == NULL){
+        pr_err("%s :i2c client is null\n",__func__);
+		return -1;
+    }
+
+	msgs[0].addr	= lt9211_info->pI2cClient->addr;
+	msgs[0].flags	= 0;
+	msgs[0].len	= sizeof(reg);
+	msgs[0].buf	= &reg;
+	msgs[1].addr	= lt9211_info->pI2cClient->addr;
+	msgs[1].flags	= I2C_M_RD;
+	msgs[1].len	= len;
+	msgs[1].buf	= buff;
+
+	res = i2c_transfer(lt9211_info->pI2cAdapter, msgs, 2);
+	if (res < 0){
+		pr_err("%s: i2c transfer failed(%d), addr:%x\n",
+				__func__, res, lt9211_info->pI2cClient->addr);
+	}else{
+		res = 0;
+    }
+	return res;
+}
+
+#if 0
+static int lt9211_i2c_write(unsigned char *buff, __u32 addr, unsigned len)
+{
+	int res = 0;
+	unsigned char *kBuf;
+	//int i;
+	struct i2c_msg msg;
+
+	if (lt9211_info->pI2cClient == NULL){
+	pr_err("%s i2c client is null.\n",__func__);
+	return -1;
+    }
+
+	kBuf = kmalloc(len+1, GFP_KERNEL);
+	memcpy(kBuf+1, buff, len);
+	kBuf[0] = addr&0xFF;
+	msg.addr = lt9211_info->pI2cClient->addr;
+	msg.flags = 0;
+	msg.len = len+1;
+	msg.buf = kBuf;
+
+	printk("%s:i2c write register\n",__func__);
+	for (i=0;i<=len;i++){
+		printk("%s i2c write %02x \n",__func__,kBuf[i]);
+	}
+
+	res = i2c_transfer(lt9211_info->pI2cClient->adapter, &msg, 1);
+	if (res < 0)
+		pr_err("%s: i2c transfer failed ,ret:%d .\n", __func__,res);
+	else
+		res = 0;
+
+	kfree(kBuf);
+	return res;
+}
+#endif
+
+static unsigned char lt9211_i2c_read_byte(u8 regaddr)
+{
+	unsigned char p_data[1];
+
+	if (lt9211_i2c_read(p_data, regaddr, 0x01)>=0) {
+//		printk("\n### %s :read reg[0x%x] <==> reg_val[0x%x]. ###\n", __func__, regaddr, p_data[0]);
+		return p_data[0];
+    }else{
+		printk("%s :read reg[0x%x] faild.\n", __func__, regaddr);
+		return -1;
+    }
+}
+
+static int lt9211_i2c_write_byte(u8 reg, u8 value)
+{
+    u8 buffer[2] = { reg, value };
+    struct i2c_msg msg;
+    int err;
+#ifdef LT9211_DEBUG_REG_VALUE
+    int ret;
+#endif
+
+    msg.addr = lt9211_info->pI2cClient->addr;
+    msg.flags = 0;
+    msg.len = sizeof(buffer);
+    msg.buf = buffer;
+
+    err = i2c_transfer(lt9211_info->pI2cAdapter, &msg, 1);
+    if (err < 0){
+        return -1;
+    }
+#ifdef LT9211_DEBUG_REG_VALUE
+	mdelay(100);
+	ret = lt9211_i2c_read_byte(reg);
+#endif
+
+    return 0;
+}
+
+#ifdef LT9211_DEBUG_REGS
+void lt9211_debug_regs(void){
+
+	unsigned char buf[100];
+	int i=0;
+	int ret;
+
+	//reg: 0x81xx
+	printk("\n--------------------0x81xx----------------------\n");
+	ret = lt9211_i2c_write_byte(0xff, 0x81);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x81%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x81xx----------------------\n");
+
+	printk("\n--------------------0x82xx----------------------\n");
+	//reg: 0x82xx
+	ret = lt9211_i2c_write_byte(0xff, 0x82);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x82%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x82xx----------------------\n");
+
+	printk("\n--------------------0x83xx----------------------\n");
+	//reg: 0x83xx
+	ret = lt9211_i2c_write_byte(0xff, 0x83);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x83%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x83xx----------------------\n");
+
+	//reg: 0x84xx
+	printk("\n--------------------0x84xx----------------------\n");
+	ret = lt9211_i2c_write_byte(0xff, 0x84);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x84%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x84xx----------------------\n");
+
+	printk("\n--------------------0x85xx----------------------\n");
+	//reg: 0x85xx
+	ret = lt9211_i2c_write_byte(0xff, 0x85);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x85%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x85xx----------------------\n");
+
+	printk("\n--------------------0x86xx----------------------\n");
+	//reg: 0x86xx
+	ret = lt9211_i2c_write_byte(0xff, 0x86);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x86%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x86xx----------------------\n");
+
+	printk("\n--------------------0x87xx----------------------\n");
+	//reg: 0x87xx
+	ret = lt9211_i2c_write_byte(0xff, 0x87);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<100;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x87%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+		mdelay(30);
+	}
+	printk("\n--------------------0x87xx----------------------\n");
+}
+#endif
+
+void LT9211_Pattern(struct video_timing *video_format)
+{
+    u32 pclk_khz;
+    u8 dessc_pll_post_div;
+    u32 pcr_m, pcr_k;
+
+    pclk_khz = video_format->pclk_khz;
+
+    lt9211_i2c_write_byte(0xff,0xf9);
+	lt9211_i2c_write_byte(0x3e,0x80);
+
+    lt9211_i2c_write_byte(0xff,0x85);
+	lt9211_i2c_write_byte(0x88,0xc0);
+
+    lt9211_i2c_write_byte(0xa1,0x74);
+    lt9211_i2c_write_byte(0xa2,0xff);
+
+	lt9211_i2c_write_byte(0xa3,(u8)((video_format->hs+video_format->hbp)/256));
+	lt9211_i2c_write_byte(0xa4,(u8)((video_format->hs+video_format->hbp)%256));//h_start
+
+	lt9211_i2c_write_byte(0xa5,(u8)((video_format->vs+video_format->vbp)%256));//v_start
+
+   	lt9211_i2c_write_byte(0xa6,(u8)(video_format->hact/256));
+	lt9211_i2c_write_byte(0xa7,(u8)(video_format->hact%256)); //hactive
+
+	lt9211_i2c_write_byte(0xa8,(u8)(video_format->vact/256));
+	lt9211_i2c_write_byte(0xa9,(u8)(video_format->vact%256));  //vactive
+
+   	lt9211_i2c_write_byte(0xaa,(u8)(video_format->htotal/256));
+	lt9211_i2c_write_byte(0xab,(u8)(video_format->htotal%256));//htotal
+
+   	lt9211_i2c_write_byte(0xac,(u8)(video_format->vtotal/256));
+	lt9211_i2c_write_byte(0xad,(u8)(video_format->vtotal%256));//vtotal
+
+   	lt9211_i2c_write_byte(0xae,(u8)(video_format->hs/256));
+	lt9211_i2c_write_byte(0xaf,(u8)(video_format->hs%256));   //hsa
+
+    lt9211_i2c_write_byte(0xb0,(u8)(video_format->vs%256));    //vsa
+
+    //dessc pll to generate pixel clk
+	lt9211_i2c_write_byte(0xff,0x82); //dessc pll
+	lt9211_i2c_write_byte(0x2d,0x48); //pll ref select xtal
+
+	if(pclk_khz < 44000)
+	{
+        lt9211_i2c_write_byte(0x35,0x83);
+		dessc_pll_post_div = 16;
+	}
+
+	else if(pclk_khz < 88000)
+	{
+	  	lt9211_i2c_write_byte(0x35,0x82);
+		dessc_pll_post_div = 8;
+	}
+
+	else if(pclk_khz < 176000)
+	{
+	  	lt9211_i2c_write_byte(0x35,0x81);
+		dessc_pll_post_div = 4;
+	}
+
+	else if(pclk_khz < 352000)
+	{
+	  	lt9211_i2c_write_byte(0x35,0x80);
+		dessc_pll_post_div = 0;
+	}
+
+	pcr_m = (pclk_khz * dessc_pll_post_div) /25;
+	pcr_k = pcr_m%1000;
+	pcr_m = pcr_m/1000;
+
+	pcr_k <<= 14;
+
+	//pixel clk
+ 	lt9211_i2c_write_byte(0xff,0xd0); //pcr
+	lt9211_i2c_write_byte(0x2d,0x7f);
+	lt9211_i2c_write_byte(0x31,0x00);
+
+	lt9211_i2c_write_byte(0x26,0x80|((u8)pcr_m));
+	lt9211_i2c_write_byte(0x27,(u8)((pcr_k>>16)&0xff)); //K
+	lt9211_i2c_write_byte(0x28,(u8)((pcr_k>>8)&0xff)); //K
+	lt9211_i2c_write_byte(0x29,(u8)(pcr_k&0xff)); //K
+}
+
+/*
+ *
+ * Setting video timing parameters
+ *
+ */
+
+void lt9211_setvideotiming(struct video_timing *video_format)
+{
+//	printk("##__%s(%d)__ start.\n", __func__, __LINE__);
+	mdelay(10);
+	lt9211_i2c_write_byte(0xff,0xd0);
+	lt9211_i2c_write_byte(0x0d,(u8)(video_format->vtotal>>8)); //vtotal[15:8]
+	lt9211_i2c_write_byte(0x0e,(u8)(video_format->vtotal)); //vtotal[7:0]
+	lt9211_i2c_write_byte(0x0f,(u8)(video_format->vact>>8)); //vactive[15:8]
+	lt9211_i2c_write_byte(0x10,(u8)(video_format->vact)); //vactive[7:0]
+	lt9211_i2c_write_byte(0x15,(u8)(video_format->vs)); //vs[7:0]
+	lt9211_i2c_write_byte(0x17,(u8)(video_format->vfp>>8)); //vfp[15:8]
+	lt9211_i2c_write_byte(0x18,(u8)(video_format->vfp)); //vfp[7:0]
+
+	lt9211_i2c_write_byte(0x11,(u8)(video_format->htotal>>8)); //htotal[15:8]
+	lt9211_i2c_write_byte(0x12,(u8)(video_format->htotal)); //htotal[7:0]
+	lt9211_i2c_write_byte(0x13,(u8)(video_format->hact>>8)); //hactive[15:8]
+	lt9211_i2c_write_byte(0x14,(u8)(video_format->hact)); //hactive[7:0]
+	lt9211_i2c_write_byte(0x16,(u8)(video_format->hs)); //hs[7:0]
+	lt9211_i2c_write_byte(0x19,(u8)(video_format->hfp>>8)); //hfp[15:8]
+	lt9211_i2c_write_byte(0x1a,(u8)(video_format->hfp)); //hfp[7:0]
+}
+
+/*
+ *
+ * There is get chip id.
+ * if get chip id secuss, will read reg values as: 0x18; 0x01; 0xe1.
+ *
+ */
+
+#if 1
+static int lt9211_get_chip_id(void)
+{
+	unsigned char buf[3];
+	int i=0;
+	int ret;
+
+	ret = lt9211_i2c_write_byte(0xff, 0x81);//register bank
+//	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<3;i++){
+		lt9211_i2c_read(buf+i, 0x00+i, 0x01);
+		printk("__%s__, reg[0x81%x](%d): val[0x%x]\n", __func__, 0x00+i, i, buf[i]);
+	}
+
+	return 0;
+}
+#endif
+
+#if 0
+static int lt9211_get_chip_id(void)
+{
+	unsigned char buf[3];
+
+	if(lt9211_i2c_write_byte(0xff,0x81) >= 0){
+		printk("%s :register bank sucess.\n",__func__);
+	}
+	else{
+		printk("%s :register bank faild.\n",__func__);
+		return -1;
+	}
+	if (lt9211_i2c_read(buf, 0x00, 0x03) >= 0) {
+	printk("%s :read chip id reg:0x%x,0x%x,0x%x\n",__func__,buf[0],buf[1],buf[2]);
+    }else{
+	printk("%s :read chip id reg faild.\n",__func__);
+        return -1;
+    }
+    return 0;
+}
+#endif
+
+/** lvds rx logic rst **/
+void lt9211_mipirx_logic_rst(void)
+{
+	printk("\n\n ##### __%s(%d)__ start. #####\n", __func__, __LINE__);
+    lt9211_i2c_write_byte(0xff,0x81);
+    lt9211_i2c_write_byte(0x0a,0xc0);
+    mdelay(10);
+    lt9211_i2c_write_byte(0x0a,0xc1);
+}
+
+/*
+ * system clock init
+ * set regs
+ */
+
+#ifdef LT9211_CONFIG_CHIP
+static void lt9211_systemint(void)
+{
+#ifdef LT9211_SYSTEMINIT_DEBUG_REG
+	int ret;
+	int i;
+	unsigned char buf[50];
+#endif
+
+//	printk("\n## __%s(%d)__ start. ##\n", __func__, __LINE__);
+
+    /* system clock init */
+    lt9211_i2c_write_byte(0xff,0x82);
+    lt9211_i2c_write_byte(0x01,0x18);
+    lt9211_i2c_write_byte(0xff,0x86);
+    lt9211_i2c_write_byte(0x06,0x61);
+    lt9211_i2c_write_byte(0x07,0xa8); //fm for sys_clk
+    lt9211_i2c_write_byte(0xff,0x87); //init txpll
+    lt9211_i2c_write_byte(0x14,0x08); //default value
+    lt9211_i2c_write_byte(0x15,0x00); //default value
+    lt9211_i2c_write_byte(0x18,0x0f);
+    lt9211_i2c_write_byte(0x22,0x08); //default value
+    lt9211_i2c_write_byte(0x23,0x00); //default value
+    lt9211_i2c_write_byte(0x26,0x0f);
+    lt9211_i2c_write_byte(0xff,0x81);
+    lt9211_i2c_write_byte(0x0B,0xFE);//rpt reset
+
+#ifdef LT9211_SYSTEMINIT_DEBUG_REG
+	printk("\n--------------------0x82xx----------------------\n");
+	//reg: 0x82xx
+	ret = lt9211_i2c_write_byte(0xff, 0x82);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<2;i++){
+		lt9211_i2c_read(buf+i, 0x01+i, 0x01);
+		printk("__%s__, reg[0x82%x](%d): val[0x%x]\n", __func__, 0x01+i, i, buf[i]);
+	}
+	printk("\n--------------------0x82xx----------------------\n");
+	lt9211_get_chip_id();
+
+	printk("\n--------------------0x86xx----------------------\n");
+	//reg: 0x86xx
+	ret = lt9211_i2c_write_byte(0xff, 0x86);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<2;i++){
+		lt9211_i2c_read(buf+i, 0x06+i, 0x01);
+		printk("__%s__, reg[0x86%x](%d): val[0x%x]\n", __func__, 0x06+i, i, buf[i]);
+	}
+	printk("\n--------------------0x86xx----------------------\n");
+
+	printk("\n--------------------0x87xx----------------------\n");
+	//reg: 0x87xx
+	ret = lt9211_i2c_write_byte(0xff, 0x87);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<13;i++){
+		lt9211_i2c_read(buf+i, 0x14+i, 0x01);
+		printk("__%s__, reg[0x87%x](%d): val[0x%x]\n", __func__, 0x14+i, i, buf[i]);
+	}
+	printk("\n--------------------0x87xx----------------------\n");
+
+	printk("\n--------------------0x81xx----------------------\n");
+	//reg: 0x81xx
+	ret = lt9211_i2c_write_byte(0xff, 0x81);
+	printk("__%s__, ret = %d\n", __func__, ret);
+	for(i=0;i<2;i++){
+		lt9211_i2c_read(buf+i, 0x0b+i, 0x01);
+		printk("__%s__, reg[0x81%x](%d): val[0x%x]\n", __func__, 0x0b+i, i, buf[i]);
+	}
+	printk("\n--------------------0x81xx----------------------\n");
+#endif
+
+}
+#endif
+
+/*
+ *
+ * MIPI RX PHY setting
+ * Open macro INPUT_PORTA to select Mipi signal input from MIPI_A port
+ * Open macro INPUT_PORTB to select Mipi signal input from MIPI_B port
+ *
+ */
+
+#ifdef LT9211_CONFIG_CHIP
+
+void lt9211_mipirxphy(void)
+{
+
+	lt9211_i2c_write_byte(0xff,0x82);
+	if(lt9211_info->input_port == 0) {		//INPUT_PORTA
+	    printk("\n### __%s(%d)__ Port A PHY Config ###\n", __func__, __LINE__);
+	    lt9211_i2c_write_byte(0x02,0x44);  //Port A MIPI mode enable
+	    lt9211_i2c_write_byte(0x04,0xa0);  //select port A clk as byteclk
+	    lt9211_i2c_write_byte(0x05,0x22);  //port A CLK lane swap
+	    lt9211_i2c_write_byte(0x07,0x9f);  //port A clk enable
+	    lt9211_i2c_write_byte(0x08,0xfc);  //port A clk enable
+	    lt9211_i2c_write_byte(0x09,0x01);  //port A P/N swap
+	    lt9211_i2c_write_byte(0x17,0x0c);
+
+	    lt9211_i2c_write_byte(0xff,0x86);
+	    lt9211_i2c_write_byte(0x33,0x1b); 	//port a lane swap	1b:no swap
+	} else {	//INPUT_PORTB
+	    printk("\n### __%s(%d)__ Port B PHY Config ###\n", __func__, __LINE__);
+	    lt9211_i2c_write_byte(0x02,0x44);  //Port A/B MIPI mode enable
+	    lt9211_i2c_write_byte(0x04,0xa1);  //select port B clk as byteclk
+    	lt9211_i2c_write_byte(0x05,0x26);  //port A CLK lane swap
+	    lt9211_i2c_write_byte(0x0d,0x26);  //port B CLK lane swap
+    	lt9211_i2c_write_byte(0x07,0x9f);  //port A clk enabl (Porta's lane0 CLK opens when portb is only opened)
+	    lt9211_i2c_write_byte(0x0f,0x9f);  //port B clk enable
+	    lt9211_i2c_write_byte(0x10,0xfc);  //select port B clk as byteclk
+	    lt9211_i2c_write_byte(0x11,0x01);  //port B P/N swap
+    	lt9211_i2c_write_byte(0x17,0x0c);
+	    lt9211_i2c_write_byte(0x1d,0x0c);
+
+	    lt9211_i2c_write_byte(0xff,0x86);
+	    lt9211_i2c_write_byte(0x34,0x1b);  //Port B Lane swap
+	}
+
+    lt9211_i2c_write_byte(0xff,0x81);
+    lt9211_i2c_write_byte(0x20,0x7f);
+    lt9211_i2c_write_byte(0x20,0xff);  //mlrx calib reset
+}
+
+#endif
+
+/*
+ * MIPI  rx setting
+ */
+
+#ifdef LT9211_CONFIG_CHIP
+void lt9211_mipirxdigital(void)
+{
+//	printk("\n### __%s(%d)__ start. ###\n", __func__, __LINE__);
+    lt9211_i2c_write_byte(0xff,0x86);
+	if(lt9211_info->input_port == 0) {
+		lt9211_i2c_write_byte(0x30,0x85);      //mipirx input port sel
+	} else {
+		lt9211_i2c_write_byte(0x30,0x8f);      //mipirx input port sel
+	}
+/* MIPI settle setting 0x15 */
+    lt9211_i2c_write_byte(0xff,0xd0);
+    lt9211_i2c_write_byte(0x02,MIPI_SETTLE_VALUE); //mipi rx controller //settl
+}
+#endif
+
+/*
+ *
+ * reset the chip
+ *
+ */
+
+static int lt9211_reset_chip(int reset_gpio)
+{
+    gpio_direction_output(reset_gpio, 0);
+	mdelay(100);
+	gpio_direction_output(reset_gpio, 1);
+	mdelay(50);
+	return 0;
+}
+
+static void set_screen_gpio(int gpio, int val)
+{
+    gpio_direction_output(gpio, val);
+	mdelay(10);
+}
+
+/*
+ *
+ * Read the input timing parameters of MIPI and calculate the output timing parameters of setting LVDS
+ * There acquisition hact and vact of resolution.
+ * The regs of 0xd082 and 0xd083 used to calculation hact.
+ * The regs of 0xd085 and 0xd086 used to calculation vact.
+ * (Notice the left shift and the sum, and then 16 is converted to 10 digits, which is the line resolution.)
+ *
+ */
+
+void lt9211_timingset(void)
+{
+	int hact;
+	int vact;
+	u8 fmt ;
+	u8 pa_lpn = 0;
+
+
+
+//	printk("\n### __%s(%d)__ ###\n", __func__, __LINE__);
+//	lt9211_mipirx_logic_rst();
+//	mdelay(500);
+	lt9211_i2c_write_byte(0xff,0xd0);
+	hact = (lt9211_i2c_read_byte(0x82)<<8) + lt9211_i2c_read_byte(0x83);
+	hact = hact/3;
+
+	fmt = (lt9211_i2c_read_byte(0x84) &0x0f);
+	vact = (lt9211_i2c_read_byte(0x85)<<8) +lt9211_i2c_read_byte(0x86);
+
+	pa_lpn = lt9211_i2c_read_byte(0x9c);
+	printk("\n## %s: hact = %d ##\n", __func__, hact);
+	printk("\n## %s: vact = %d ##\n", __func__, vact);
+
+	mdelay(10);
+    if ((hact == video_800x480_60Hz.hact ) &&( vact == video_800x480_60Hz.vact ))
+    {
+        pvideo_format = &video_800x480_60Hz;
+        lt9211_setvideotiming(&video_800x480_60Hz);
+    }
+    else if ((hact == video_1024x600_60Hz.hact ) &&( vact == video_1024x600_60Hz.vact ))
+    {
+        pvideo_format = &video_1024x600_60Hz;
+        lt9211_setvideotiming(&video_1024x600_60Hz);
+    }
+    else if ((hact == video_1280x720_60Hz.hact ) &&( vact == video_1280x720_60Hz.vact ))
+    {
+        pvideo_format = &video_1280x720_60Hz;
+        lt9211_setvideotiming(&video_1280x720_60Hz);
+    }
+	else if ((hact == video_1280x800_60Hz.hact ) &&( vact == video_1280x800_60Hz.vact ))
+	{
+		pvideo_format = &video_1280x800_60Hz;
+		lt9211_setvideotiming(&video_1280x800_60Hz);
+	}
+	else if ((hact == video_1920x720_60Hz.hact ) &&( vact == video_1920x720_60Hz.vact ))
+    {
+        pvideo_format = &video_1920x720_60Hz;
+        lt9211_setvideotiming(&video_1920x720_60Hz);
+    }
+    else if ((hact == video_1366x768_60Hz.hact ) &&( vact == video_1366x768_60Hz.vact ))
+    {
+        pvideo_format = &video_1366x768_60Hz;
+        lt9211_setvideotiming(&video_1366x768_60Hz);
+    }
+    else if ((hact == video_1920x1080_60Hz.hact ) &&( vact == video_1920x1080_60Hz.vact ))
+    {
+        pvideo_format = &video_1920x1080_60Hz;
+        lt9211_setvideotiming(&video_1920x1080_60Hz);
+    }
+
+    else if ((hact == video_1920x1200_60Hz.hact ) &&( vact == video_1920x1200_60Hz.vact ))
+    {
+
+        pvideo_format = &video_1920x1200_60Hz;
+        lt9211_setvideotiming(&video_1920x1200_60Hz);
+    }
+	else if ((hact == video_1280x1024_60hz.hact) && (vact == video_1280x1024_60hz.vact))
+	{
+		pvideo_format = &video_1280x1024_60hz;
+		lt9211_setvideotiming(&video_1280x1024_60hz);
+	}
+    else
+    {
+		pvideo_format = NULL;
+		printk("\n## pvideo_format is NULL ##\n");
+    }
+}
+
+/*
+ *
+ * Setting the PCLK of LVDS output from the pvideo_format structure
+ *
+ */
+
+void lt9211_desscpll(void)
+{
+//	printk("\n### __%s(%d)__ start. ###\n", __func__, __LINE__);
+	lt9211_i2c_write_byte(0xff,0x82);
+	lt9211_i2c_write_byte(0x2d,0x48);
+	if(pvideo_format->pclk_khz < 44000) {
+		lt9211_i2c_write_byte(0x35,0x83);
+	} else if(pvideo_format->pclk_khz < 88000) {
+		lt9211_i2c_write_byte(0x35,0x82);
+	} else if(pvideo_format->pclk_khz < 176000) {
+		lt9211_i2c_write_byte(0x35,0x81);
+	}
+	printk("\n### __%s(%d)__ end. pixclk: %d ###\n", __func__, __LINE__, pvideo_format->pclk_khz);
+}
+
+/*
+ *
+ * mipi pcr_stable check, if pcr stable is ok, else if pcr unstable was has problem.
+ *
+ *
+ */
+
+void lt9211_mipipcr(void)
+{
+	u8 loopx;
+
+//	printk("\n### __%s(%d)__ write regs start. ###\n", __func__, __LINE__);
+	mdelay(10);
+	lt9211_i2c_write_byte(0xff,0xd0);
+	lt9211_i2c_write_byte(0x26,0x17);
+	lt9211_i2c_write_byte(0x27,0xC3);
+	lt9211_i2c_write_byte(0x2d,0x30);  //PCR M overflow limit setting.
+	lt9211_i2c_write_byte(0x31,0x10);  //PCR M underflow limit setting.
+	lt9211_i2c_write_byte(0x23,0x20);
+
+	lt9211_i2c_write_byte(0x38,0x02);
+	lt9211_i2c_write_byte(0x39,0x10);
+	lt9211_i2c_write_byte(0x3a,0x20);
+	lt9211_i2c_write_byte(0x3b,0x60);
+	lt9211_i2c_write_byte(0x3f,0x04);
+	lt9211_i2c_write_byte(0x40,0x08);
+	lt9211_i2c_write_byte(0x41,0x10);
+	mdelay(10);
+	lt9211_i2c_write_byte(0xff,0x81);
+	lt9211_i2c_write_byte(0x0B,0xEE);
+	lt9211_i2c_write_byte(0x0B,0xFE);
+
+	mdelay(300);
+	for(loopx = 0; loopx < 5; loopx++) //Check pcr_stable
+	{
+		mdelay(200);
+		lt9211_i2c_write_byte(0xff,0xd0);
+		if(lt9211_i2c_read_byte(0x87)&0x08)
+		{
+			printk("\n __%s(%d)__, LT9211 pcr stable.\n", __func__, __LINE__);
+			break;
+		}
+		else
+		{
+			msleep(100);
+			printk("\n __%s(%d)__, LT9211 pcr unstable!!!!\n", __func__, __LINE__);
+		}
+    }
+}
+
+/*
+ * Configuring single or double LVDS signal output.You can view the LCD's datasheet determination, there is Dual LVDS.
+ * such as:
+ * OUTPUT_LVDS_1_PORT: signal output
+ * OUTPUT_LVDS_2_PORT: dual output
+ */
+
+void lt9211_txphy(void)
+{
+//	printk("\n### __%s(%d)__ start. ###\n", __func__, __LINE__);
+	lt9211_i2c_write_byte(0xff,0x82);
+	lt9211_i2c_write_byte(0x62,0x00); //ttl output disable
+    if(lt9211_info->output_port == OUTPUT_PORT2) {
+        lt9211_i2c_write_byte(0x3b,0xb8);
+    } else {
+		lt9211_i2c_write_byte(0x3b,0x38);
+	}
+    lt9211_i2c_write_byte(0x3e,0x92);
+    lt9211_i2c_write_byte(0x3f,0x48);
+    lt9211_i2c_write_byte(0x40,0x31);
+    lt9211_i2c_write_byte(0x43,0x80);
+    lt9211_i2c_write_byte(0x44,0x00);
+    lt9211_i2c_write_byte(0x45,0x00);
+    lt9211_i2c_write_byte(0x49,0x00);
+    lt9211_i2c_write_byte(0x4a,0x01);
+    lt9211_i2c_write_byte(0x4e,0x00);
+    lt9211_i2c_write_byte(0x4f,0x00);
+    lt9211_i2c_write_byte(0x50,0x00);
+    lt9211_i2c_write_byte(0x53,0x00);
+    lt9211_i2c_write_byte(0x54,0x01);
+
+    lt9211_i2c_write_byte(0xff,0x86);
+    lt9211_i2c_write_byte(0x46,0x10);
+	if(lt9211_info->output_swap) {
+    	lt9211_i2c_write_byte(0x46,0x40);
+		printk("\r\nLVDS Output Port Swap!");
+	}
+    lt9211_i2c_write_byte(0xff,0x81);
+    lt9211_i2c_write_byte(0x20,0x7b);
+    lt9211_i2c_write_byte(0x20,0xff); //mlrx mltx calib reset
+}
+
+void lt9211_txdigital(void)
+{
+    printk("\r\nLT9211 LVDS_OUTPUT_MODE: ");
+    lt9211_i2c_write_byte(0xff,0x85); /* lvds tx controller */
+    lt9211_i2c_write_byte(0x59,0x40);
+    if(lt9211_info->lvds_data_formate == VESA ) {
+        printk("\r\nData Format: VESA");
+        lt9211_i2c_write_byte(0x59, (lt9211_i2c_read_byte(0x59) & 0x7f));
+    }else if(lt9211_info->lvds_data_formate == JEIDA ) {
+        printk("\r\nData Format: JEIDA");
+        lt9211_i2c_write_byte(0x59, (lt9211_i2c_read_byte(0x59) | 0x80));
+    }
+
+    if(lt9211_info->lvds_color_depth == DEPTH_6BIT ) {
+        printk("\r\nColorDepth: 6Bit");
+        lt9211_i2c_write_byte(0x59, (lt9211_i2c_read_byte(0x59) & 0xef));
+    }else if(lt9211_info->lvds_color_depth == DEPTH_8BIT ) {
+        printk("\r\nColorDepth: 8Bit");
+        lt9211_i2c_write_byte(0x59, (lt9211_i2c_read_byte(0x59) | 0x10));
+    }
+
+    if(lt9211_info->lvds_mode == SYNC_MODE ) {
+        printk("\r\nLVDS_MODE: Sync Mode");
+        lt9211_i2c_write_byte(0x59, (lt9211_i2c_read_byte(0x59) & 0xdf));
+    }else if(lt9211_info->lvds_mode == DE_MODE ) {
+        printk("\r\nLVDS_MODE: De Mode");
+        lt9211_i2c_write_byte(0x59, (lt9211_i2c_read_byte(0x59) | 0x20));
+    }
+
+    lt9211_i2c_write_byte(0x5a,0xaa);
+    lt9211_i2c_write_byte(0x5b,0xaa);
+	if(lt9211_info->output_port == OUTPUT_PORT2) {
+		printk("\r\nLVDS Output Port Num: 2Port");
+        lt9211_i2c_write_byte(0x5c,0x05);	//lvdstx port sel 01:dual;00:single
+    } else {
+        lt9211_i2c_write_byte(0x5c,0x04);
+		printk("\r\nLVDS Output Port Num: 1Port");
+    }
+    lt9211_i2c_write_byte(0x88,0x40);
+    lt9211_i2c_write_byte(0xa1,0x77);
+    lt9211_i2c_write_byte(0xff,0x86);
+    lt9211_i2c_write_byte(0x40,0x40); //tx_src_sel
+    /*port src sel*/
+    lt9211_i2c_write_byte(0x41,0x34);
+    lt9211_i2c_write_byte(0x42,0x10);
+    lt9211_i2c_write_byte(0x43,0x23); //pt0_tx_src_sel
+    lt9211_i2c_write_byte(0x44,0x41);
+    lt9211_i2c_write_byte(0x45,0x02); //pt1_tx_src_scl
+
+	if(lt9211_info->lvds_data_formate == JEIDA ) {
+        lt9211_i2c_write_byte(0xff,0xd8);
+    	lt9211_i2c_write_byte(0x11,0x40);
+    }
+}
+
+void lt9211_txpll(void)
+{
+    u8 loopx = 0;
+
+    lt9211_i2c_write_byte(0xff,0x82);
+    lt9211_i2c_write_byte(0x36,0x01); //b7:txpll_pd
+	if(lt9211_info->output_port == OUTPUT_PORT2) {
+        lt9211_i2c_write_byte(0x37,0x2a);
+    } else {
+        lt9211_i2c_write_byte(0x37,0x29);
+    }
+
+	if(lt9211_info->reg_config == 0) {
+	    lt9211_i2c_write_byte(0x38,0x86);
+	    lt9211_i2c_write_byte(0x39,0xb0);
+	    lt9211_i2c_write_byte(0x3a,0x0e);
+	    lt9211_i2c_write_byte(0xff,0x87);
+	    lt9211_i2c_write_byte(0x37,0x0e);
+	    lt9211_i2c_write_byte(0x38,0x00);
+	    lt9211_i2c_write_byte(0x39,0x00);
+	    lt9211_i2c_write_byte(0x13,0x00);
+	    lt9211_i2c_write_byte(0x13,0x80);
+
+	    lt9211_i2c_write_byte(0x2f,0x06);  //0x06:no ssc; 0x16:ssc_en
+	    lt9211_i2c_write_byte(0x30,0x03);  //prd[13:8]
+	    lt9211_i2c_write_byte(0x31,0x41);  //prd[7:0]
+	    lt9211_i2c_write_byte(0x32,0x00);  //delta1[13:8]
+	    lt9211_i2c_write_byte(0x33,0x09);  //delta1[7:0]
+	    lt9211_i2c_write_byte(0x34,0x00);  //delta[13:8]
+	    lt9211_i2c_write_byte(0x35,0x12);  //delta[7:0]
+	} else if(lt9211_info->reg_config == 1) {
+		lt9211_i2c_write_byte(0x38,0x06);
+	    lt9211_i2c_write_byte(0x39,0x30);
+	    lt9211_i2c_write_byte(0x3a,0x8e);
+	    lt9211_i2c_write_byte(0xff,0x87);
+	    lt9211_i2c_write_byte(0x37,0x14);
+	    lt9211_i2c_write_byte(0x13,0x00);
+	    lt9211_i2c_write_byte(0x13,0x80);
+	}
+
+	mdelay(100);
+    for(loopx = 0; loopx < 10; loopx++) { //Check Tx PLL cal
+        lt9211_i2c_write_byte(0xff,0x87);
+        if(lt9211_i2c_read_byte(0x1f)& 0x80) {
+            if(lt9211_i2c_read_byte(0x20)& 0x80) {
+                printk("\n ## LT9211 tx pll lock ##\n");
+            } else {
+                printk("\n ## LT9211 tx pll unlocked ##\n");
+            }
+            printk("\n ## LT9211 tx pll cal done ##\n");
+            break;
+        } else {
+            printk("\n ## LT9211 tx pll unlocked ##\n");
+        }
+    }
+	if(lt9211_info->reg_config == 0) {
+		printk("\n ## LT9211 lvds tx pll: ssc enabled on 1.5 ##\n");
+		lt9211_i2c_write_byte(0x2f,0x16);
+	}
+}
+
+#ifdef LT9211_VEDIO_CHECK_DEBUG
+void lt9211_videocheckdebug(void)
+{
+	int sync_polarity;
+	int hact, vact;
+	int hs, vs;
+	int hbp, vbp;
+	int htotal, vtotal;
+	int hfp, vfp;
+
+    lt9211_i2c_write_byte(0xff,0x86);
+    lt9211_i2c_write_byte(0x20,0x00);
+    mdelay(10);
+
+    sync_polarity = lt9211_i2c_read_byte(0x70);
+    vs = lt9211_i2c_read_byte(0x71);
+
+    hs = lt9211_i2c_read_byte(0x72);
+    hs = (hs<<8) + lt9211_i2c_read_byte(0x73);
+
+    vbp = lt9211_i2c_read_byte(0x74);
+    vfp = lt9211_i2c_read_byte(0x75);
+
+    hbp = lt9211_i2c_read_byte(0x76);
+    hbp = (hbp<<8) + lt9211_i2c_read_byte(0x77);
+
+    hfp = lt9211_i2c_read_byte(0x78);
+    hfp = (hfp<<8) + lt9211_i2c_read_byte(0x79);
+
+    vtotal = lt9211_i2c_read_byte(0x7A);
+    vtotal = (vtotal<<8) + lt9211_i2c_read_byte(0x7B);
+
+    htotal = lt9211_i2c_read_byte(0x7C);
+    htotal = (htotal<<8) + lt9211_i2c_read_byte(0x7D);
+
+    vact = lt9211_i2c_read_byte(0x7E);
+    vact = (vact<<8)+ lt9211_i2c_read_byte(0x7F);
+
+    hact = lt9211_i2c_read_byte(0x80);
+    hact = (hact<<8) + lt9211_i2c_read_byte(0x81);
+
+	printk("\n lt9211 dumpinfo h: hfp[%d], hs[%d], hbp[%d], hact[%d], htotal[%d]\n",
+							hfp, hs, hbp, hact, htotal);
+	printk("\n lt9211 dumpinfo v: vfp[%d], vs[%d], vbp[%d], vact[%d], vtotal[%d]\n",
+							vfp, vs, vbp, vact, vtotal);
+
+}
+#endif
+
+#ifdef LT9211_BT_SET
+void lt9211_BT_set(void)
+{
+    u16 tmp_data;
+	u16 hact, vact;
+    u16 hs, vs;
+    u16 hbp, vbp;
+    u16 htotal, vtotal;
+    u16 hfp, vfp;
+
+	printk("\n### __%s(%d)__ ###\n", __func__, __LINE__);
+    hact = pvideo_format->hact;
+    vact = pvideo_format->vact;
+    htotal = pvideo_format->htotal;
+    vtotal = pvideo_format->vtotal;
+    hs = pvideo_format->hs;
+    vs = pvideo_format->vs;
+    hfp = pvideo_format->hfp;
+    vfp = pvideo_format->vfp;
+    hbp = pvideo_format->hbp;
+    vbp = pvideo_format->vbp;
+
+	if( (lt9211_outputmodde == OUTPUT_BT1120_16BIT) || (lt9211_outputmodde == OUTPUT_BT656_8BIT) )
+	{
+		tmp_data = hs+hbp;
+		lt9211_i2c_write_byte(0xff,0x85);
+		lt9211_i2c_write_byte(0x61,(u8)(tmp_data>>8));
+		lt9211_i2c_write_byte(0x62,(u8)tmp_data);
+		lt9211_i2c_write_byte(0x63,(u8)(hact>>8));
+		lt9211_i2c_write_byte(0x64,(u8)hact);
+		lt9211_i2c_write_byte(0x65,(u8)(htotal>>8));
+		lt9211_i2c_write_byte(0x66,(u8)htotal);
+		tmp_data = vs+vbp;
+		lt9211_i2c_write_byte(0x67,(u8)tmp_data);
+		lt9211_i2c_write_byte(0x68,0x00);
+		lt9211_i2c_write_byte(0x69,(u8)(vact>>8));
+		lt9211_i2c_write_byte(0x6a,(u8)vact);
+		lt9211_i2c_write_byte(0x6b,(u8)(vtotal>>8));
+		lt9211_i2c_write_byte(0x6c,(u8)vtotal);
+	}
+}
+#endif
+
+void lt9211_txlogic_rst(void)
+{
+	lt9211_i2c_write_byte(0xff, 0x81);
+	lt9211_i2c_write_byte(0x0d, 0x1a);
+	mdelay(10);
+	lt9211_i2c_write_byte(0x0d, 0x1e);
+	//printk("__%s(), %d__\n", __func__, __LINE__);
+}
+
+void lt9211_config(void)
+{
+	//Reset chip
+	gpio_direction_output(lt9211_info->reset_gpio, 0);
+	mdelay(100);
+	gpio_direction_output(lt9211_info->reset_gpio, 1);
+	mdelay(50);
+
+	//Get chip id
+	lt9211_get_chip_id();
+	mdelay(50);
+
+	//Config chip
+	lt9211_systemint();
+	lt9211_mipirxphy();
+	lt9211_mipirxdigital();
+	mdelay(50);
+}
+
+void lt9211_mipitolvds_init(void)
+{
+	printk("zzz:enter lt9211_mipitolvds_init\n");
+
+	if (mipi_dsi_2lvds_init == 0) {
+		printk("mipi2lvds lt9211 init fail, mipi_dsi_2lvds_init[%d]\n", mipi_dsi_2lvds_init);
+		return;
+	}
+
+	lt9211_config();
+
+    lt9211_timingset();
+    if( pvideo_format != NULL ) {
+        lt9211_desscpll();
+        lt9211_mipipcr();
+
+        //Tx config
+        lt9211_txphy();
+        lt9211_txdigital();
+        lt9211_txpll();
+		lt9211_txlogic_rst(); 	//add for solve the problem of edge pixel vanishing
+#ifdef LT9211_VEDIO_CHECK_DEBUG
+		lt9211_videocheckdebug();
+#endif
+
+#ifdef LT9211_BT_SET
+        lt9211_BT_set();
+#endif
+
+#ifdef LT9211_PATTERN_TEST
+		LT9211_Pattern(pvideo_format);  //test  //xsj
+#endif
+    }
+    mdelay(50);
+}
+EXPORT_SYMBOL(lt9211_mipitolvds_init);
+
+static int lt9211_parse_of(struct lt9211_priv *priv)
+{
+	struct device *dev = priv->dev;
+	struct device_node *node = dev->of_node;
+	enum of_gpio_flags flags;
+
+	priv->reset_gpio = of_get_named_gpio_flags(node, "reset_gpio", 0, &flags);
+	dev_info(dev, "## -- reset_gpio pin number is %d -- ##\n", priv->reset_gpio);
+	if (!gpio_is_valid(priv->reset_gpio)) {
+		dev_info(dev, "reset_gpio: %d is invalid\n", priv->reset_gpio);
+		return -ENODEV;
+	}
+
+	if (gpio_request(priv->reset_gpio, "reset_gpio")) {
+		dev_info(dev, "reset_gpio: %d request failed!\n", priv->reset_gpio);
+		return -ENODEV;
+	}
+
+	priv->screen_reset = of_get_named_gpio_flags(node, "screen-reset", 0, &flags);
+	if (gpio_is_valid(priv->screen_reset)) {
+		dev_info(dev, "## -- screen_reset pin number is %d -- ##\n", priv->screen_reset);
+		if (gpio_request(priv->screen_reset, "shlr-gpio")) {
+			dev_info(dev, "screen_reset: %d request failed!\n", priv->screen_reset);
+			goto free_res;
+		}
+	}
+
+	priv->screen_stbyb = of_get_named_gpio_flags(node, "screen-stbyb", 0, &flags);
+	if (gpio_is_valid(priv->screen_stbyb)) {
+		dev_info(dev, "## -- screen_stbyb pin number is %d -- ##\n", priv->screen_stbyb);
+		if (gpio_request(priv->screen_stbyb, "updn-gpio")) {
+			dev_info(dev, "screen_stbyb: %d request failed!\n", priv->screen_stbyb);
+			goto free_shlr;
+		}
+	}
+	return 0;
+
+free_shlr:
+	if (gpio_is_valid(priv->screen_reset))
+		gpio_free(priv->screen_reset);
+free_res:
+	gpio_free(priv->reset_gpio);
+	return -ENODEV;
+}
+
+
+//------platform lt9211 dev start-------
+static int lt9211_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct lt9211_priv *priv;
+	struct device_node *node = client->dev.of_node;
+	int ret = 0;
+	u32 val = 0;
+
+#ifdef LT9211_MIPI_STATUS
+	int i;
+	unsigned char buf[50];
+#endif
+
+	printk("enter lt9211_probe\n");
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &client->dev;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	//Creat i2c
+	priv->pI2cAdapter = client->adapter;
+	if (priv->pI2cAdapter == NULL) {
+		printk("%s() failed to get i2c adapter\n", __func__);
+		goto out;
+	}
+
+	//Create i2c device
+	priv->pI2cClient = client;
+	if (priv->pI2cClient==NULL) {
+        printk("%s i2c client is null\n",__func__);
+		goto out;
+	}
+
+	ret = lt9211_parse_of(priv);
+	if (ret) {
+		printk("lt9211_parse_of failed! err:%d\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "input-port", &val);
+	if (ret) {
+		printk("no input-port define\n");
+		priv->input_port = 0;
+	} else {
+		priv->input_port = val;
+	}
+
+	ret = of_property_read_u32(node, "output-port", &val);
+	if (ret) {
+		printk("no output-port define\n");
+		priv->output_port = 2;
+	} else {
+		priv->output_port = val;
+	}
+
+	ret = of_property_read_u32(node, "output-swap", &val);
+	if (ret) {
+		printk("no output-swap define\n");
+		priv->output_swap = 0;
+	} else {
+		priv->output_swap = val;
+	}
+
+	// Get lvds info
+	ret = of_property_read_u32(node, "data-formate", &val);
+	if (ret) {
+		printk("no odata-formate define\n");
+		priv->lvds_data_formate = VESA;
+	} else {
+		priv->lvds_data_formate = val;
+	}
+
+	ret = of_property_read_u32(node, "color-depth", &val);
+	if (ret) {
+		printk("no color-depth define\n");
+		priv->lvds_color_depth = DEPTH_8BIT;
+	} else {
+		priv->lvds_color_depth = val;
+	}
+
+	ret = of_property_read_u32(node, "lvds-mode", &val);
+	if (ret) {
+		printk("no lvds-mode define\n");
+		priv->lvds_mode = SYNC_MODE;
+	} else {
+		priv->lvds_mode = val;
+	}
+
+	ret = of_property_read_u32(node, "reg-config", &val);
+	if (ret) {
+		printk("no lvds-mode define\n");
+		priv->reg_config = 0;
+	} else {
+		priv->reg_config = val;
+	}
+
+	printk("%s()---->input_port = %d output_port = %d data-formate = %d "
+			"color-depth = %d lvds-mode=%d reg_config = %d\n", __func__, priv->input_port,
+			priv->output_port, priv->lvds_data_formate, priv->lvds_color_depth,
+			priv->lvds_mode, priv->reg_config);
+
+	lt9211_info = priv;
+
+	//Reset chip
+	lt9211_reset_chip(priv->reset_gpio);
+	if (gpio_is_valid(priv->screen_reset)) {
+		set_screen_gpio(priv->screen_reset, 1);
+	}
+
+	if (gpio_is_valid(priv->screen_reset)) {
+		set_screen_gpio(priv->screen_stbyb, 1);
+	}
+
+	//Get chip id
+//	lt9211_get_chip_id();
+//	mdelay(100);
+
+#ifdef LT9211_DEBUG_REGS
+	lt9211_debug_regs();
+#endif
+
+#ifdef LT9211_CONFIG_CHIP
+	//Config chip
+//	lt9211_systemint();
+//	lt9211_mipirxphy();
+//	lt9211_mipirxdigital();
+//	mdelay(100);
+#endif
+
+#ifdef LT9211_MIPI_STATUS
+	printk("\n--------------------0xd0xx----------------------\n");
+	//reg: 0xd0xx
+	ret = lt9211_i2c_write_byte(0xff, 0xd0);
+	printk("__%s__, ret = %d(0:true;1:fail)\n", __func__, ret);
+	for(i=0;i<30;i++){
+		lt9211_i2c_read(buf+i, 0x80+i, 0x01);
+		printk("__%s__, reg[0xd0%x](%d): val[0x%x]\n", __func__, 0x80+i, i, buf[i]);
+		mdelay(50);
+	}
+	printk("\n--------------------0xd0xx----------------------\n");
+#endif
+	mipi_dsi_2lvds_init = 1;
+	lt9211_mipitolvds_init();
+
+	printk("lt9211 -- %s -- sucess.\n", __func__);
+	return 0;
+out:
+	kfree(priv);
+	return ret;
+}
+
+static int lt9211_remove(struct i2c_client *client)
+{
+	printk("===== %s =====\n", __func__);
+	return 0;
+};
+
+static int lt9211_suspend(struct device *dev)
+{
+	pr_info("__%s__, line(%d): enter suspend\n", __func__, __LINE__);
+	return 0;
+}
+
+static int lt9211_resume(struct device *dev)
+{
+
+	pr_info("__%s__, line(%d): enter resume\n", __func__, __LINE__);
+	return 0;
+}
+
+
+static SIMPLE_DEV_PM_OPS(lt9211_pm_ops, lt9211_suspend, lt9211_resume);
+
+static const struct i2c_device_id lt9211_id[] = {
+	{LT9211_I2C_NAME, 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, lt9211_id);
+
+static const struct of_device_id lt9211_dt_match[] = {
+	{ .compatible = "geniatech,lt9211_1080p"},
+	{},
+};
+
+static struct i2c_driver lt9211_driver = {
+	.driver = {
+		.name = LT9211_I2C_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = lt9211_dt_match,
+		.pm = &lt9211_pm_ops,
+	},
+	.probe		= lt9211_probe,
+	.remove		= lt9211_remove,
+	.id_table	= lt9211_id,
+};
+
+
+static int __init lt9211_init(void)
+{
+	int ret;
+	printk("===== %s =====\n", __func__);
+	ret = i2c_add_driver(&lt9211_driver);
+	if(ret != 0){
+		printk(KERN_ERR "Failed to register lt9211 I2C driver: %d\n",ret);
+	}
+	return 0;
+}
+
+static void __exit lt9211_exit(void)
+{
+	printk("===== %s =====\n", __func__);
+	i2c_del_driver(&lt9211_driver);
+}
+
+module_init(lt9211_init);
+module_exit(lt9211_exit);
+
+MODULE_DESCRIPTION("Geniatech lt9211 ic driver");
+MODULE_AUTHOR("cai.zhongding@geniatech.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/lt9211/lt9211_1080p.h b/drivers/video/lt9211/lt9211_1080p.h
new file mode 100644
index 000000000..cefcc82f8
--- /dev/null
+++ b/drivers/video/lt9211/lt9211_1080p.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+  * @project: LT9211
+  * @file: lt9211.h
+  * @author: caizd
+  * @company: LONTIUM COPYRIGHT and CONFIDENTIAL
+  * @date: 2019.09.03
+******************************************************************************/
+
+#ifndef _LT9211_H
+#define _LT9211_H
+
+#define _uart_debug_
+
+/******************* MIPI Input Config ********************/
+//#define MIPI_CSI
+#define INPUT_PORTA /* 信号从lt9211的mipi A 口输入*/
+//#define INPUT_PORTB /* 信号从lt9211的mipi B 口输入 */
+
+/******************* Output Config ********************/
+typedef enum LT9211_OUTPUTMODE_ENUM
+{
+    OUTPUT_PORT0 = 0,	//only port 0 output
+    OUTPUT_PORT1 = 1,	//only port 1 output
+    OUTPUT_PORT2 = 2,	//port 0 and 1 output
+}_lt9211_outputmodde;
+
+#define lt9211_outputmodde  OUTPUT_PORT2
+
+typedef enum  LT9211_MIPI_LANE_NUMBER
+{
+	MIPI_1_LANE = 1,
+	MIPI_2_LANE = 2,
+	MIPI_3_LANE = 3,
+	MIPI_4_LANE = 0   //default 4Lane
+} _lt9211_mipi_lane;
+
+#define MIPI_LANE_CNT  MIPI_4_LANE
+
+#define MIPI_SETTLE_VALUE 0x0a //0x05
+
+typedef enum VIDEO_INPUTMODE_ENUM
+{
+    Input_RGB888,
+    Input_YCbCr444,
+    Input_YCbCr422_16BIT
+}
+_Video_Input_Mode;
+
+#define Video_Input_Mode  Input_RGB888
+
+//////////option for debug///////////
+struct video_timing{
+u16 hfp;
+u16 hs;
+u16 hbp;
+u16 hact;
+u16 htotal;
+u16 vfp;
+u16 vs;
+u16 vbp;
+u16 vact;
+u16 vtotal;
+u32 pclk_khz;
+};
+
+struct timing{
+u16 hfp;
+u16 hs;
+u16 hbp;
+u16 hact;
+u16 htotal;
+u16 vfp;
+u16 vs;
+u16 vbp;
+u16 vact;
+u16 vtotal;
+u32 pclk_khz;
+};
+
+typedef enum videoformat{
+    video_1280x720_60Hz_vic=1,
+    video_1366x768_60Hz_vic,
+    video_1280x1024_60Hz_vic,
+    video_1920x1080_60Hz_vic,
+    video_1920x1200_60Hz_vic,
+    video_none
+}_videoformat;
+
+typedef struct lane_no{
+u8	swing_high_byte;
+u8	swing_low_byte;
+u8	emph_high_byte;
+u8	emph_low_byte;
+}_lane_no;
+
+#endif
-- 
2.17.1

